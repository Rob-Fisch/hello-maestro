import * as Print from 'expo-print';
import { PDFDocument } from 'pdf-lib';
import * as Sharing from 'expo-sharing';
import * as FileSystem from 'expo-file-system/legacy';
import { Platform, Alert } from 'react-native';
import { Routine, UserSettings } from '@/store/types';

const base64ToUint8Array = (base64: string) => {
    const raw = atob(base64);
    const uint8Array = new Uint8Array(raw.length);
    for (let i = 0; i < raw.length; i++) {
        uint8Array[i] = raw.charCodeAt(i);
    }
    return uint8Array;
};

export const resolveFileUri = async (uri: string): Promise<string | null> => {
    if (!uri || (Platform.OS as any) === 'web' || uri.startsWith('http') || uri.startsWith('data:')) return uri;

    let cleanUri = uri;
    try {
        if (uri.includes('%')) {
            cleanUri = decodeURIComponent(uri);
        }
    } catch (e) { }

    if (Platform.OS !== 'web' && !cleanUri.startsWith('file://') && !cleanUri.startsWith('content://')) {
        cleanUri = `file://${cleanUri}`;
    }

    const docDir = FileSystem.documentDirectory;
    if ((Platform.OS as any) === 'ios' && cleanUri.includes('/Application/') && docDir) {
        const uuidMatch = docDir.match(/Application\/([A-Z0-9-]+)\//);
        if (uuidMatch && uuidMatch[1]) {
            const currentUuid = uuidMatch[1];
            const oldUuidMatch = cleanUri.match(/Application\/([A-Z0-9-]+)\//);
            if (oldUuidMatch && oldUuidMatch[1] && oldUuidMatch[1] !== currentUuid) {
                cleanUri = cleanUri.replace(oldUuidMatch[1], currentUuid);
            }
        }
    }

    let fileInfo = await FileSystem.getInfoAsync(cleanUri);
    if (fileInfo.exists) return cleanUri;

    if (docDir) {
        const filename = cleanUri.split('/').pop();
        const currentDest = `${docDir}${filename}`;
        const checkDest = await FileSystem.getInfoAsync(currentDest);
        if (checkDest.exists) return currentDest;
    }

    const checkOriginal = await FileSystem.getInfoAsync(uri);
    if (checkOriginal.exists) return uri;

    return null;
};

const getBase64 = async (uri: string) => {
    const resolvedUri = await resolveFileUri(uri);
    if (!resolvedUri) return null;
    if (resolvedUri.startsWith('http') || resolvedUri.startsWith('data:')) return resolvedUri;

    try {
        const base64 = await FileSystem.readAsStringAsync(resolvedUri, { encoding: 'base64' });
        const extension = resolvedUri.split('.').pop()?.toLowerCase();
        const mimeType = (extension === 'png') ? 'image/png' : 'image/jpeg';
        return `data:${mimeType};base64,${base64}`;
    } catch (e) {
        return null;
    }
};

const generateTOC = (routine: Routine) => {
    return `
        <html>
            <head>
                <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no" />
                <style>
                    body { font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; padding: 60px; color: #333; }
                    h1 { font-size: 36px; border-bottom: 3px solid #3b82f6; padding-bottom: 15px; margin-bottom: 40px; }
                    .toc-item { display: flex; align-items: baseline; margin-bottom: 15px; font-size: 18px; }
                    .toc-name { font-weight: bold; color: #111; }
                    .toc-leader { flex: 1; border-bottom: 1px dotted #ccc; margin: 0 10px; }
                    .toc-type { font-size: 12px; color: #666; text-transform: uppercase; font-weight: 800; }
                </style>
            </head>
            <body>
                <h1>Set List: ${routine.title}</h1>
                <div style="margin-bottom: 40px; font-style: italic; color: #666;">
                    ${routine.blocks.length} items in this set
                </div>
                ${routine.blocks.map((block, i) => `
                    <div class="toc-item">
                        <span class="toc-name">${i + 1}. ${block.title}</span>
                        <span class="toc-leader"></span>
                        <span class="toc-type">${block.type === 'sheet_music' ? 'üéº Sheet Music' : 'üìù Text'}</span>
                    </div>
                `).join('')}
                <div style="margin-top: 100px; text-align: center; font-size: 12px; color: #aaa; border-top: 1px solid #eee; padding-top: 20px;">
                    Generated by HelloMaestro &bull; ${new Date().toLocaleDateString()}
                </div>
            </body>
        </html>
    `;
};

const generateHtmlForSegment = (blocks: any[], routineTitle: string, segmentIndex: number, routineDescription?: string) => {
    return `
        <html>
            <head>
                <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no" />
                <style>
                    body { font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; padding: 40px; color: #333; line-height: 1.6; }
                    h1 { color: #1a1a1a; font-size: 32px; margin-bottom: 5px; border-bottom: 2px solid #3b82f6; padding-bottom: 10px; }
                    h2 { color: #666; font-size: 18px; font-weight: normal; margin-bottom: 40px; }
                    .block { 
                        margin-bottom: 30px; 
                        padding: 25px; 
                        border: 1px solid #e5e7eb;
                        border-left: 5px solid #3b82f6;
                        border-radius: 12px;
                        page-break-inside: avoid;
                        page-break-before: always;
                        background-color: #fcfcfc;
                    }
                    .block-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px; }
                    .block-title { font-weight: bold; font-size: 22px; color: #111; }
                    .block-type { background-color: #3b82f6; padding: 4px 10px; border-radius: 6px; font-size: 10px; text-transform: uppercase; letter-spacing: 0.1em; color: #fff; font-weight: 800; }
                    .block-content { margin-top: 15px; white-space: pre-wrap; font-size: 16px; color: #4b5563; }
                    .media-box { margin-top: 20px; text-align: center; }
                    .media-image { max-width: 100%; max-height: 600px; border-radius: 8px; border: 1px solid #eaeaea; }
                    .link-box { margin-top: 15px; font-size: 14px; padding: 10px; background-color: #f3f4f6; border-radius: 8px; }
                    .link-box a { color: #2563eb; text-decoration: none; font-weight: bold; }
                    .footer { margin-top: 50px; font-size: 12px; color: #999; text-align: center; border-top: 1px solid #eee; padding-top: 20px; }
                </style>
            </head>
            <body>
                ${segmentIndex === 0 ? `
                    <h1>${routineTitle}</h1>
                    ${routineDescription ? `<h2>${routineDescription}</h2>` : '<div style="margin-bottom: 40px;"></div>'}
                ` : ''}
                <div class="blocks">
                    ${blocks.map((block) => `
                        <div class="block">
                            <div class="block-header">
                                <div class="block-title">${block.title}</div>
                                <div class="block-type">${block.type}</div>
                            </div>
                            ${block.content ? `<div class="block-content">${block.content}</div>` : ''}
                            ${block.mediaUri ? (
            block.isPdf ? `
                                    <div class="link-box">
                                        <span>üìÑ Attached PDF: </span>
                                        <strong>${block.mediaUri.split('/').pop()}</strong>
                                    </div>
                                ` : `
                                    <div class="media-box">
                                        ${block.base64Uri ? `
                                            <img src="${block.base64Uri}" class="media-image" alt="Media content" />
                                        ` : `
                                            <div style="color: #999; font-style: italic; padding: 10px; border: 1px dashed #ccc;">
                                                Image not found on this device
                                            </div>
                                        `}
                                    </div>
                                `
        ) : ''}
                            ${block.linkUrl ? `
                                <div class="link-box">
                                    <span>üîó External Link: </span>
                                    <a href="${block.linkUrl}">${block.linkUrl}</a>
                                </div>
                            ` : ''}
                        </div>
                    `).join('')}
                </div>
                <div class="footer">
                    Generated by HelloMaestro &bull; ${new Date().toLocaleDateString()}
                </div>
            </body>
        </html>
    `;
};

export const exportToPdf = async (routine: Routine, settings: UserSettings) => {
    try {
        const mergedPdf = await PDFDocument.create();
        let currentHtmlBlocks: any[] = [];

        const flushHtmlBlocks = async () => {
            if (currentHtmlBlocks.length === 0) return;
            const processedBlocks = [];
            for (const block of currentHtmlBlocks) {
                const isPdf = block.mediaUri?.toLowerCase().split('?')[0].endsWith('.pdf');
                if (block.mediaUri && !isPdf) {
                    const base64 = await getBase64(block.mediaUri);
                    processedBlocks.push({ ...block, base64Uri: base64, isPdf: false });
                } else {
                    processedBlocks.push({ ...block, isPdf: !!isPdf });
                }
            }
            const html = generateHtmlForSegment(processedBlocks, routine.title, mergedPdf.getPageCount(), routine.description);
            const { base64 } = await Print.printToFileAsync({ html, base64: true });
            if (base64) {
                const pdfBytes = base64ToUint8Array(base64);
                const htmlPdf = await PDFDocument.load(pdfBytes);
                const pages = await mergedPdf.copyPages(htmlPdf, htmlPdf.getPageIndices());
                pages.forEach((page) => mergedPdf.addPage(page));
            }
            currentHtmlBlocks = [];
        };

        if (settings.includeTOC) {
            const tocHtml = generateTOC(routine);
            const { base64: tocB64 } = await Print.printToFileAsync({ html: tocHtml, base64: true });
            if (tocB64) {
                const tocDoc = await PDFDocument.load(base64ToUint8Array(tocB64));
                const [tocPage] = await mergedPdf.copyPages(tocDoc, [0]);
                mergedPdf.addPage(tocPage);
            }
        }

        for (const block of routine.blocks) {
            const isPdf = block.mediaUri?.toLowerCase().split('?')[0].endsWith('.pdf');
            if (isPdf && block.mediaUri) {
                await flushHtmlBlocks();
                const resolvedUri = await resolveFileUri(block.mediaUri);
                if (resolvedUri) {
                    try {
                        const pdfBase64 = await FileSystem.readAsStringAsync(resolvedUri, { encoding: 'base64' });
                        const pdfBytes = base64ToUint8Array(pdfBase64);
                        const attachmentPdf = await PDFDocument.load(pdfBytes);
                        const pages = await mergedPdf.copyPages(attachmentPdf, attachmentPdf.getPageIndices());
                        pages.forEach((page) => mergedPdf.addPage(page));
                    } catch (e) {
                        console.warn('Failed to merge PDF block:', block.title, e);
                    }
                }
            } else {
                currentHtmlBlocks.push(block);
            }
        }

        await flushHtmlBlocks();

        const pdfBase64 = await mergedPdf.saveAsBase64();
        const filename = `${routine.title.replace(/[^a-zA-Z0-9]/g, '_')}_Master.pdf`;
        const fileUri = `${FileSystem.documentDirectory}${filename}`;

        await FileSystem.writeAsStringAsync(fileUri, pdfBase64, { encoding: 'base64' });

        if (Platform.OS === 'web') {
            const pdfBytes = await mergedPdf.save();
            const blob = new Blob([pdfBytes as any], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        } else {
            await Sharing.shareAsync(fileUri, { UTI: '.pdf', mimeType: 'application/pdf' });
        }
    } catch (error) {
        console.error('Error generating PDF:', error);
        Alert.alert('Error', 'Failed to generate PDF.');
    }
};
